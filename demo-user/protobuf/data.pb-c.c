/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: data.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "data.pb-c.h"
void   subid__init
                     (Subid         *message)
{
  static const Subid init_value = SUBID__INIT;
  *message = init_value;
}
size_t subid__get_packed_size
                     (const Subid *message)
{
  assert(message->base.descriptor == &subid__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t subid__pack
                     (const Subid *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &subid__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t subid__pack_to_buffer
                     (const Subid *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &subid__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Subid *
       subid__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Subid *)
     protobuf_c_message_unpack (&subid__descriptor,
                                allocator, len, data);
}
void   subid__free_unpacked
                     (Subid *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &subid__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ack__init
                     (Ack         *message)
{
  static const Ack init_value = ACK__INIT;
  *message = init_value;
}
size_t ack__get_packed_size
                     (const Ack *message)
{
  assert(message->base.descriptor == &ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ack__pack
                     (const Ack *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ack__pack_to_buffer
                     (const Ack *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Ack *
       ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Ack *)
     protobuf_c_message_unpack (&ack__descriptor,
                                allocator, len, data);
}
void   ack__free_unpacked
                     (Ack *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   gpio__init
                     (Gpio         *message)
{
  static const Gpio init_value = GPIO__INIT;
  *message = init_value;
}
size_t gpio__get_packed_size
                     (const Gpio *message)
{
  assert(message->base.descriptor == &gpio__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t gpio__pack
                     (const Gpio *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &gpio__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t gpio__pack_to_buffer
                     (const Gpio *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &gpio__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Gpio *
       gpio__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Gpio *)
     protobuf_c_message_unpack (&gpio__descriptor,
                                allocator, len, data);
}
void   gpio__free_unpacked
                     (Gpio *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &gpio__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   voltage__init
                     (Voltage         *message)
{
  static const Voltage init_value = VOLTAGE__INIT;
  *message = init_value;
}
size_t voltage__get_packed_size
                     (const Voltage *message)
{
  assert(message->base.descriptor == &voltage__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t voltage__pack
                     (const Voltage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &voltage__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t voltage__pack_to_buffer
                     (const Voltage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &voltage__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Voltage *
       voltage__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Voltage *)
     protobuf_c_message_unpack (&voltage__descriptor,
                                allocator, len, data);
}
void   voltage__free_unpacked
                     (Voltage *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &voltage__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   gsensor__accel__init
                     (Gsensor__Accel         *message)
{
  static const Gsensor__Accel init_value = GSENSOR__ACCEL__INIT;
  *message = init_value;
}
void   gsensor__gyro__init
                     (Gsensor__Gyro         *message)
{
  static const Gsensor__Gyro init_value = GSENSOR__GYRO__INIT;
  *message = init_value;
}
void   gsensor__init
                     (Gsensor         *message)
{
  static const Gsensor init_value = GSENSOR__INIT;
  *message = init_value;
}
size_t gsensor__get_packed_size
                     (const Gsensor *message)
{
  assert(message->base.descriptor == &gsensor__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t gsensor__pack
                     (const Gsensor *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &gsensor__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t gsensor__pack_to_buffer
                     (const Gsensor *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &gsensor__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Gsensor *
       gsensor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Gsensor *)
     protobuf_c_message_unpack (&gsensor__descriptor,
                                allocator, len, data);
}
void   gsensor__free_unpacked
                     (Gsensor *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &gsensor__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   gps__init
                     (Gps         *message)
{
  static const Gps init_value = GPS__INIT;
  *message = init_value;
}
size_t gps__get_packed_size
                     (const Gps *message)
{
  assert(message->base.descriptor == &gps__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t gps__pack
                     (const Gps *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &gps__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t gps__pack_to_buffer
                     (const Gps *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &gps__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Gps *
       gps__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Gps *)
     protobuf_c_message_unpack (&gps__descriptor,
                                allocator, len, data);
}
void   gps__free_unpacked
                     (Gps *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &gps__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   vehic__init
                     (Vehic         *message)
{
  static const Vehic init_value = VEHIC__INIT;
  *message = init_value;
}
size_t vehic__get_packed_size
                     (const Vehic *message)
{
  assert(message->base.descriptor == &vehic__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t vehic__pack
                     (const Vehic *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &vehic__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t vehic__pack_to_buffer
                     (const Vehic *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &vehic__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Vehic *
       vehic__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Vehic *)
     protobuf_c_message_unpack (&vehic__descriptor,
                                allocator, len, data);
}
void   vehic__free_unpacked
                     (Vehic *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &vehic__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   can__init
                     (Can         *message)
{
  static const Can init_value = CAN__INIT;
  *message = init_value;
}
size_t can__get_packed_size
                     (const Can *message)
{
  assert(message->base.descriptor == &can__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t can__pack
                     (const Can *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &can__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t can__pack_to_buffer
                     (const Can *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &can__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Can *
       can__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Can *)
     protobuf_c_message_unpack (&can__descriptor,
                                allocator, len, data);
}
void   can__free_unpacked
                     (Can *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &can__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   flash__init
                     (Flash         *message)
{
  static const Flash init_value = FLASH__INIT;
  *message = init_value;
}
size_t flash__get_packed_size
                     (const Flash *message)
{
  assert(message->base.descriptor == &flash__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t flash__pack
                     (const Flash *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &flash__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t flash__pack_to_buffer
                     (const Flash *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &flash__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Flash *
       flash__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Flash *)
     protobuf_c_message_unpack (&flash__descriptor,
                                allocator, len, data);
}
void   flash__free_unpacked
                     (Flash *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &flash__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   version__init
                     (Version         *message)
{
  static const Version init_value = VERSION__INIT;
  *message = init_value;
}
size_t version__get_packed_size
                     (const Version *message)
{
  assert(message->base.descriptor == &version__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t version__pack
                     (const Version *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &version__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t version__pack_to_buffer
                     (const Version *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &version__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Version *
       version__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Version *)
     protobuf_c_message_unpack (&version__descriptor,
                                allocator, len, data);
}
void   version__free_unpacked
                     (Version *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &version__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   rtc__init
                     (Rtc         *message)
{
  static const Rtc init_value = RTC__INIT;
  *message = init_value;
}
size_t rtc__get_packed_size
                     (const Rtc *message)
{
  assert(message->base.descriptor == &rtc__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t rtc__pack
                     (const Rtc *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &rtc__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t rtc__pack_to_buffer
                     (const Rtc *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &rtc__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Rtc *
       rtc__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Rtc *)
     protobuf_c_message_unpack (&rtc__descriptor,
                                allocator, len, data);
}
void   rtc__free_unpacked
                     (Rtc *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &rtc__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   serial__set__init
                     (SerialSet         *message)
{
  static const SerialSet init_value = SERIAL__SET__INIT;
  *message = init_value;
}
size_t serial__set__get_packed_size
                     (const SerialSet *message)
{
  assert(message->base.descriptor == &serial__set__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t serial__set__pack
                     (const SerialSet *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &serial__set__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t serial__set__pack_to_buffer
                     (const SerialSet *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &serial__set__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SerialSet *
       serial__set__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SerialSet *)
     protobuf_c_message_unpack (&serial__set__descriptor,
                                allocator, len, data);
}
void   serial__set__free_unpacked
                     (SerialSet *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &serial__set__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   serial__data__init
                     (SerialData         *message)
{
  static const SerialData init_value = SERIAL__DATA__INIT;
  *message = init_value;
}
size_t serial__data__get_packed_size
                     (const SerialData *message)
{
  assert(message->base.descriptor == &serial__data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t serial__data__pack
                     (const SerialData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &serial__data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t serial__data__pack_to_buffer
                     (const SerialData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &serial__data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SerialData *
       serial__data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SerialData *)
     protobuf_c_message_unpack (&serial__data__descriptor,
                                allocator, len, data);
}
void   serial__data__free_unpacked
                     (SerialData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &serial__data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor subid__field_descriptors[2] =
{
  {
    "id",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Subid, id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "subdata",
    2,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Subid, n_subdata),
    offsetof(Subid, subdata),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned subid__field_indices_by_name[] = {
  0,   /* field[0] = id */
  1,   /* field[1] = subdata */
};
static const ProtobufCIntRange subid__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor subid__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Subid",
  "Subid",
  "Subid",
  "",
  sizeof(Subid),
  2,
  subid__field_descriptors,
  subid__field_indices_by_name,
  1,  subid__number_ranges,
  (ProtobufCMessageInit) subid__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ack__field_descriptors[2] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Ack, type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "rev1",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Ack, has_rev1),
    offsetof(Ack, rev1),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ack__field_indices_by_name[] = {
  1,   /* field[1] = rev1 */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ack",
  "Ack",
  "Ack",
  "",
  sizeof(Ack),
  2,
  ack__field_descriptors,
  ack__field_indices_by_name,
  1,  ack__number_ranges,
  (ProtobufCMessageInit) ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor gpio__field_descriptors[2] =
{
  {
    "gpio",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gpio, gpio),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "value",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Gpio, has_value),
    offsetof(Gpio, value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned gpio__field_indices_by_name[] = {
  0,   /* field[0] = gpio */
  1,   /* field[1] = value */
};
static const ProtobufCIntRange gpio__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor gpio__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Gpio",
  "Gpio",
  "Gpio",
  "",
  sizeof(Gpio),
  2,
  gpio__field_descriptors,
  gpio__field_indices_by_name,
  1,  gpio__number_ranges,
  (ProtobufCMessageInit) gpio__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor voltage__field_descriptors[2] =
{
  {
    "id",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Voltage, id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "value",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Voltage, has_value),
    offsetof(Voltage, value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned voltage__field_indices_by_name[] = {
  0,   /* field[0] = id */
  1,   /* field[1] = value */
};
static const ProtobufCIntRange voltage__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor voltage__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Voltage",
  "Voltage",
  "Voltage",
  "",
  sizeof(Voltage),
  2,
  voltage__field_descriptors,
  voltage__field_indices_by_name,
  1,  voltage__number_ranges,
  (ProtobufCMessageInit) voltage__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor gsensor__accel__field_descriptors[3] =
{
  {
    "x",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor__Accel, x),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "y",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor__Accel, y),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "z",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor__Accel, z),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned gsensor__accel__field_indices_by_name[] = {
  0,   /* field[0] = x */
  1,   /* field[1] = y */
  2,   /* field[2] = z */
};
static const ProtobufCIntRange gsensor__accel__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor gsensor__accel__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Gsensor.accel",
  "Accel",
  "Gsensor__Accel",
  "",
  sizeof(Gsensor__Accel),
  3,
  gsensor__accel__field_descriptors,
  gsensor__accel__field_indices_by_name,
  1,  gsensor__accel__number_ranges,
  (ProtobufCMessageInit) gsensor__accel__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor gsensor__gyro__field_descriptors[3] =
{
  {
    "x",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor__Gyro, x),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "y",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor__Gyro, y),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "z",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor__Gyro, z),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned gsensor__gyro__field_indices_by_name[] = {
  0,   /* field[0] = x */
  1,   /* field[1] = y */
  2,   /* field[2] = z */
};
static const ProtobufCIntRange gsensor__gyro__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor gsensor__gyro__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Gsensor.gyro",
  "Gyro",
  "Gsensor__Gyro",
  "",
  sizeof(Gsensor__Gyro),
  3,
  gsensor__gyro__field_descriptors,
  gsensor__gyro__field_indices_by_name,
  1,  gsensor__gyro__number_ranges,
  (ProtobufCMessageInit) gsensor__gyro__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor gsensor__field_descriptors[5] =
{
  {
    "interval",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor, interval),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "a",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Gsensor, a),
    &gsensor__accel__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "g",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Gsensor, g),
    &gsensor__gyro__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "event",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Gsensor, has_event),
    offsetof(Gsensor, event),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "threshold",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Gsensor, threshold),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned gsensor__field_indices_by_name[] = {
  1,   /* field[1] = a */
  3,   /* field[3] = event */
  2,   /* field[2] = g */
  0,   /* field[0] = interval */
  4,   /* field[4] = threshold */
};
static const ProtobufCIntRange gsensor__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor gsensor__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Gsensor",
  "Gsensor",
  "Gsensor",
  "",
  sizeof(Gsensor),
  5,
  gsensor__field_descriptors,
  gsensor__field_indices_by_name,
  1,  gsensor__number_ranges,
  (ProtobufCMessageInit) gsensor__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor gps__field_descriptors[1] =
{
  {
    "nmea",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(Gps, nmea),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned gps__field_indices_by_name[] = {
  0,   /* field[0] = nmea */
};
static const ProtobufCIntRange gps__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor gps__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Gps",
  "Gps",
  "Gps",
  "",
  sizeof(Gps),
  1,
  gps__field_descriptors,
  gps__field_indices_by_name,
  1,  gps__number_ranges,
  (ProtobufCMessageInit) gps__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor vehic__field_descriptors[4] =
{
  {
    "interval",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(Vehic, interval),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "acc",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Vehic, has_acc),
    offsetof(Vehic, acc),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "total",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Vehic, has_total),
    offsetof(Vehic, total),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pulse",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(Vehic, has_pulse),
    offsetof(Vehic, pulse),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned vehic__field_indices_by_name[] = {
  1,   /* field[1] = acc */
  0,   /* field[0] = interval */
  3,   /* field[3] = pulse */
  2,   /* field[2] = total */
};
static const ProtobufCIntRange vehic__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor vehic__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Vehic",
  "Vehic",
  "Vehic",
  "",
  sizeof(Vehic),
  4,
  vehic__field_descriptors,
  vehic__field_indices_by_name,
  1,  vehic__number_ranges,
  (ProtobufCMessageInit) vehic__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor can__field_descriptors[3] =
{
  {
    "canid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Can, canid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "id",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Can, id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Can, has_data),
    offsetof(Can, data),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned can__field_indices_by_name[] = {
  0,   /* field[0] = canid */
  2,   /* field[2] = data */
  1,   /* field[1] = id */
};
static const ProtobufCIntRange can__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor can__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Can",
  "Can",
  "Can",
  "",
  sizeof(Can),
  3,
  can__field_descriptors,
  can__field_indices_by_name,
  1,  can__number_ranges,
  (ProtobufCMessageInit) can__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor flash__field_descriptors[3] =
{
  {
    "offset",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Flash, offset),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "size",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Flash, size),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Flash, has_data),
    offsetof(Flash, data),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned flash__field_indices_by_name[] = {
  2,   /* field[2] = data */
  0,   /* field[0] = offset */
  1,   /* field[1] = size */
};
static const ProtobufCIntRange flash__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor flash__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Flash",
  "Flash",
  "Flash",
  "",
  sizeof(Flash),
  3,
  flash__field_descriptors,
  flash__field_indices_by_name,
  1,  flash__number_ranges,
  (ProtobufCMessageInit) flash__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor version__field_descriptors[2] =
{
  {
    "btime",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Version, btime),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "os_name",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(Version, os_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned version__field_indices_by_name[] = {
  0,   /* field[0] = btime */
  1,   /* field[1] = os_name */
};
static const ProtobufCIntRange version__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor version__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Version",
  "Version",
  "Version",
  "",
  sizeof(Version),
  2,
  version__field_descriptors,
  version__field_indices_by_name,
  1,  version__number_ranges,
  (ProtobufCMessageInit) version__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor rtc__field_descriptors[1] =
{
  {
    "rtime",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Rtc, rtime),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned rtc__field_indices_by_name[] = {
  0,   /* field[0] = rtime */
};
static const ProtobufCIntRange rtc__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor rtc__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Rtc",
  "Rtc",
  "Rtc",
  "",
  sizeof(Rtc),
  1,
  rtc__field_descriptors,
  rtc__field_indices_by_name,
  1,  rtc__number_ranges,
  (ProtobufCMessageInit) rtc__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor serial__set__field_descriptors[5] =
{
  {
    "port",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SerialSet, port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "baudrate",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SerialSet, baudrate),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "parity",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SerialSet, parity),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "databit",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SerialSet, databit),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stopbit",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SerialSet, stopbit),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned serial__set__field_indices_by_name[] = {
  1,   /* field[1] = baudrate */
  3,   /* field[3] = databit */
  2,   /* field[2] = parity */
  0,   /* field[0] = port */
  4,   /* field[4] = stopbit */
};
static const ProtobufCIntRange serial__set__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor serial__set__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Serial_Set",
  "SerialSet",
  "SerialSet",
  "",
  sizeof(SerialSet),
  5,
  serial__set__field_descriptors,
  serial__set__field_indices_by_name,
  1,  serial__set__number_ranges,
  (ProtobufCMessageInit) serial__set__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor serial__data__field_descriptors[2] =
{
  {
    "port",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SerialData, port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(SerialData, data),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned serial__data__field_indices_by_name[] = {
  1,   /* field[1] = data */
  0,   /* field[0] = port */
};
static const ProtobufCIntRange serial__data__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor serial__data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Serial_Data",
  "SerialData",
  "SerialData",
  "",
  sizeof(SerialData),
  2,
  serial__data__field_descriptors,
  serial__data__field_indices_by_name,
  1,  serial__data__number_ranges,
  (ProtobufCMessageInit) serial__data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCEnumValue ioc__enum_values_by_number[16] =
{
  { "SET", "IOC__SET", 1 },
  { "GET", "IOC__GET", 2 },
  { "DATA", "IOC__DATA", 3 },
  { "SEND", "IOC__SEND", 4 },
  { "FILTER", "IOC__FILTER", 5 },
  { "POWERON", "IOC__POWERON", 6 },
  { "LEDON", "IOC__LEDON", 7 },
  { "INIT", "IOC__INIT", 8 },
  { "CLEAR", "IOC__CLEAR", 9 },
  { "REBOOT", "IOC__REBOOT", 10 },
  { "LEDOFF", "IOC__LEDOFF", 11 },
  { "PWROFF", "IOC__PWROFF", 12 },
  { "SETWAKE", "IOC__SETWAKE", 13 },
  { "SUSPEND", "IOC__SUSPEND", 14 },
  { "SLEEP", "IOC__SLEEP", 15 },
  { "UPGRADE", "IOC__UPGRADE", 16 },
};
static const ProtobufCIntRange ioc__value_ranges[] = {
{1, 0},{0, 16}
};
static const ProtobufCEnumValueIndex ioc__enum_values_by_name[16] =
{
  { "CLEAR", 8 },
  { "DATA", 2 },
  { "FILTER", 4 },
  { "GET", 1 },
  { "INIT", 7 },
  { "LEDOFF", 10 },
  { "LEDON", 6 },
  { "POWERON", 5 },
  { "PWROFF", 11 },
  { "REBOOT", 9 },
  { "SEND", 3 },
  { "SET", 0 },
  { "SETWAKE", 12 },
  { "SLEEP", 14 },
  { "SUSPEND", 13 },
  { "UPGRADE", 15 },
};
const ProtobufCEnumDescriptor ioc__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "IOC",
  "IOC",
  "IOC",
  "",
  16,
  ioc__enum_values_by_number,
  16,
  ioc__enum_values_by_name,
  1,
  ioc__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
